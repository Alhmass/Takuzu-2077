        -:    0:Source:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/lib/mode_error.c
        -:    0:Graph:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/build/CMakeFiles/game.dir/lib/mode_error.c.gcno
        -:    0:Data:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/build/CMakeFiles/game.dir/lib/mode_error.c.gcda
        -:    0:Runs:80
        -:    1:#include "takuzu.h"
        -:    2:
        6:    3:void print_array(square *array, uint size) {
       42:    4:    for (uint i = 0; i < size; i++) {
       36:    5:        printf("[%d] ", array[i]);
        -:    6:    }
        6:    7:    printf("\n");
        6:    8:}
        -:    9:
      392:   10:square *get_row(cgame g, uint i) {
      392:   11:    cgame_test(g, "g is NULL");
      392:   12:    uint cols_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_cols(g);
      392:   13:    square *row = malloc(sizeof(square) * cols_g);
      392:   14:    pointer_test(row, "malloc failed");
     2716:   15:    for (uint j = 0; j < cols_g; j++) row[j] = game_get_square(g, i, j);
      392:   16:    return row;
        -:   17:}
        -:   18:
      246:   19:square *get_col(cgame g, uint j) {
      246:   20:    cgame_test(g, "g is NULL");
      246:   21:    uint rows_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_rows(g);
      246:   22:    square *col = malloc(sizeof(square) * rows_g);
      246:   23:    pointer_test(col, "malloc failed");
     1690:   24:    for (uint i = 0; i < rows_g; i++) {
     1444:   25:        col[i] = game_get_square(g, i, j);
        -:   26:    }
      246:   27:    return col;
        -:   28:}
        -:   29:
       56:   30:void rotate_array(square *array, uint size) {
       56:   31:    pointer_test(array, "array is NULL");
       56:   32:    square start = array[0];
      336:   33:    for (uint i = 0; i < size - 1; i++) array[i] = array[i + 1];
       56:   34:    array[size - 1] = start;
       56:   35:}
        -:   36:
     4540:   37:int get_number(int s) {
     4540:   38:    if (s == 0) {
       10:   39:        return -1;
     4530:   40:    } else if (s == 1 || s == 3) {
     2332:   41:        return 0;
        -:   42:    }
     2198:   43:    return 1;
        -:   44:}
        -:   45:
      418:   46:bool is_consecutive(square *array, uint size, int current) {
      418:   47:    if (current == -1)
    #####:   48:        return false;
        -:   49:
      418:   50:    uint consecutive = 0;
      418:   51:    uint current_counter = 0;
     2710:   52:    for (uint i = 0; i < size; i++) {
     2382:   53:        if (get_number(array[i]) == current) {
     1264:   54:            if (++current_counter > (size / 2) + (size % 2)) {
       10:   55:                return true;
        -:   56:            }
     1254:   57:            if (++consecutive >= size / 2) {
       80:   58:                return true;
        -:   59:            }
        -:   60:        } else
     1118:   61:            consecutive = 0;
        -:   62:    }
      328:   63:    return false;
        -:   64:}
        -:   65:
        8:   66:bool is_consecutive_grid(cgame g, uint i, uint j) {
        8:   67:    square *tabRows = get_row(g, i);
       8*:   68:    uint rows_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_rows(g);
       8*:   69:    uint cols_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_cols(g);
       32:   70:    for (uint x = 0; x < cols_g; x++) {
       28:   71:        rotate_array(tabRows, cols_g);
       28:   72:        if (is_consecutive(tabRows, cols_g, game_get_number(g, i, j))) {
        4:   73:            free(tabRows);
        4:   74:            return true;
        -:   75:        }
        -:   76:    }
        4:   77:    free(tabRows);
        4:   78:    square *tabCols = get_col(g, j);
       16:   79:    for (uint y = 0; y < rows_g; y++) {
       14:   80:        rotate_array(tabCols, rows_g);
       14:   81:        if (is_consecutive(tabCols, rows_g, game_get_number(g, i, j))) {
        2:   82:            free(tabCols);
        2:   83:            return true;
        -:   84:        }
        -:   85:    }
        2:   86:    free(tabCols);
        2:   87:    return false;
        -:   88:}
        -:   89:
      120:   90:bool is_array_same(square *array1, square *array2, uint size) {
      684:   91:    for (uint i = 0; i < size; i++) {
      590:   92:        if (get_number(array1[i]) != get_number(array2[i])) {
       26:   93:            return false;
        -:   94:        }
        -:   95:    }
       94:   96:    return true;
        -:   97:}
        -:   98:
      174:   99:bool is_array_full(square *array, uint size) {
     1136:  100:    for (uint i = 0; i < size; i++) {
      968:  101:        if (get_number(array[i]) == -1)
        6:  102:            return false;
        -:  103:    }
      168:  104:    return true;
        -:  105:}
        -:  106:
       78:  107:bool is_unique_array(cgame g, uint i, uint j) {
      78*:  108:    uint rows_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_rows(g);
      78*:  109:    uint cols_g = (g->version == 1) ? DEFAULT_SIZE : game_nb_cols(g);
       78:  110:    square *row_i = get_row(g, i);
       78:  111:    if (is_array_full(row_i, cols_g)) {
       98:  112:        for (uint x = 0; x < rows_g; x++) {
       96:  113:            if (x != i) {
       80:  114:                square *row_x = get_row(g, x);
       80:  115:                if (is_array_full(row_x, cols_g)) {
       80:  116:                    if (is_array_same(row_i, row_x, cols_g)) {
       74:  117:                        free(row_x);
       74:  118:                        free(row_i);
       74:  119:                        return false;
        -:  120:                    }
        -:  121:                }
        6:  122:                free(row_x);
        -:  123:            }
        -:  124:        }
        -:  125:    }
        4:  126:    free(row_i);
        -:  127:
        4:  128:    square *col_j = get_col(g, j);
        4:  129:    if (is_array_full(col_j, rows_g)) {
       18:  130:        for (uint y = 0; y < cols_g; y++) {
       16:  131:            if (y != j) {
       12:  132:                square *col_y = get_col(g, y);
       12:  133:                if (is_array_full(col_y, rows_g)) {
        8:  134:                    if (is_array_same(col_j, col_y, rows_g)) {
        2:  135:                        free(col_y);
        2:  136:                        free(col_j);
        2:  137:                        return false;
        -:  138:                    }
        -:  139:                }
       10:  140:                free(col_y);
        -:  141:            }
        -:  142:        }
        -:  143:    }
        2:  144:    free(col_j);
        2:  145:    return true;
        -:  146:}
