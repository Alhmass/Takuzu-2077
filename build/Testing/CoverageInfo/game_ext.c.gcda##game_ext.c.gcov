        -:    0:Source:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/lib/game_ext.c
        -:    0:Graph:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/build/CMakeFiles/game.dir/lib/game_ext.c.gcno
        -:    0:Data:/mnt/c/Users/Alexandre L-P/Documents/takuzu-01c/build/CMakeFiles/game.dir/lib/game_ext.c.gcda
        -:    0:Runs:80
        -:    1:#include "takuzu.h"
        -:    2:
       52:    3:game game_new_ext(uint nb_rows, uint nb_cols, square *squares, bool wrapping, bool unique) {
       52:    4:    game g = malloc(sizeof(struct game_s));
       52:    5:    pointer_test(g, "game_nex_ext: game_ext malloc failed");
       52:    6:    pointer_test(squares, "game_nex_ext: squares is NULL");
       52:    7:    g->game = malloc(sizeof(square) * (nb_rows * nb_cols));
       52:    8:    pointer_test(g->game, "game_nex_ext: game malloc failed");
       52:    9:    memcpy(g->game, squares, sizeof(square) * (nb_rows * nb_cols));
       52:   10:    g->nb_rows = nb_rows;
       52:   11:    g->nb_cols = nb_cols;
       52:   12:    g->wrapping = wrapping;
       52:   13:    g->unique = unique;
       52:   14:    g->history = ms_create(1);
       52:   15:    g->backup = ms_create(1);
       52:   16:    g->version = 2;
       52:   17:    return g;
        -:   18:}
        -:   19:
       28:   20:game game_new_empty_ext(uint nb_rows, uint nb_cols, bool wrapping, bool unique) {
       28:   21:    game g = malloc(sizeof(struct game_s));
       28:   22:    pointer_test(g, "game_nex_ext: game_ext malloc failed");
       28:   23:    g->game = malloc(sizeof(square) * (nb_rows * nb_cols));
       28:   24:    pointer_test(g->game, "game_nex_ext: game malloc failed");
       28:   25:    memset(g->game, 0, sizeof(square) * (nb_rows * nb_cols));
       28:   26:    g->nb_rows = nb_rows;
       28:   27:    g->nb_cols = nb_cols;
       28:   28:    g->wrapping = wrapping;
       28:   29:    g->unique = unique;
       28:   30:    g->history = ms_create(1);
       28:   31:    g->backup = ms_create(1);
       28:   32:    g->version = 2;
       28:   33:    return g;
        -:   34:}
        -:   35:
     4258:   36:uint game_nb_rows(cgame g) {
     4258:   37:    cgame_test(g, "g is NULL");
     4258:   38:    return g->nb_rows;
        -:   39:}
        -:   40:
     4400:   41:uint game_nb_cols(cgame g) {
     4400:   42:    cgame_test(g, "g is NULL");
     4400:   43:    return g->nb_cols;
        -:   44:}
        -:   45:
      192:   46:bool game_is_wrapping(cgame g) {
      192:   47:    cgame_test(g, "g is NULL");
      192:   48:    return g->wrapping;
        -:   49:}
        -:   50:
      166:   51:bool game_is_unique(cgame g) {
      166:   52:    cgame_test(g, "g is NULL");
      166:   53:    return g->unique;
        -:   54:}
        -:   55:
       16:   56:void game_undo(game g) {
       16:   57:    cgame_test(g, "g is NULL");
       16:   58:    if (ms_is_empty(g->history)) {
    #####:   59:        printf("game_undo: history is empty\n");
    #####:   60:        return;
        -:   61:    }
       16:   62:    game_set_square(g, ms_top_row(g->history), ms_top_col(g->history), ms_top_p(g->history));
       16:   63:    ms_push(g->backup, ms_top(g->history));
       16:   64:    ms_pop(g->history);
        -:   65:}
        -:   66:
        6:   67:void game_redo(game g) {
        6:   68:    cgame_test(g, "g is NULL");
        6:   69:    if (ms_is_empty(g->backup)) {
    #####:   70:        printf("game_redo: backup is empty\n");
    #####:   71:        return;
        -:   72:    }
        6:   73:    game_set_square(g, ms_top_row(g->backup), ms_top_col(g->backup), ms_top_s(g->backup));
        6:   74:    ms_push(g->history, ms_top(g->backup));
        6:   75:    ms_pop(g->backup);
        -:   76:}
